import { performance } from 'perf_hooks';
import * as colors from 'colorette';
import { normalizeTypes, BaseResolver, resolveDocument, detectSpec, getTypes, normalizeVisitors, walkDocument, Stats, bundle, logger, } from '@redocly/openapi-core';
import { getFallbackApisOrExit, printExecutionTime } from '../utils/miscellaneous.js';
const statsAccumulator = {
    refs: { metric: 'ðŸš— References', total: 0, color: 'red', items: new Set() },
    externalDocs: { metric: 'ðŸ“¦ External Documents', total: 0, color: 'magenta' },
    schemas: { metric: 'ðŸ“ˆ Schemas', total: 0, color: 'white' },
    parameters: { metric: 'ðŸ‘‰ Parameters', total: 0, color: 'yellow', items: new Set() },
    links: { metric: 'ðŸ”— Links', total: 0, color: 'cyan', items: new Set() },
    pathItems: { metric: 'ðŸ”€ Path Items', total: 0, color: 'green' },
    webhooks: { metric: 'ðŸŽ£ Webhooks', total: 0, color: 'green' },
    operations: { metric: 'ðŸ‘· Operations', total: 0, color: 'yellow' },
    tags: { metric: 'ðŸ”– Tags', total: 0, color: 'white', items: new Set() },
};
function printStatsStylish(statsAccumulator) {
    for (const node in statsAccumulator) {
        const { metric, total, color } = statsAccumulator[node];
        logger.output(colors[color](`${metric}: ${total} \n`));
    }
}
function printStatsJson(statsAccumulator) {
    const json = {};
    for (const key of Object.keys(statsAccumulator)) {
        json[key] = {
            metric: statsAccumulator[key].metric,
            total: statsAccumulator[key].total,
        };
    }
    logger.output(JSON.stringify(json, null, 2));
}
function printStatsMarkdown(statsAccumulator) {
    let output = '| Feature  | Count  |\n| --- | --- |\n';
    for (const key of Object.keys(statsAccumulator)) {
        output +=
            '| ' +
                statsAccumulator[key].metric +
                ' | ' +
                statsAccumulator[key].total +
                ' |\n';
    }
    logger.output(output);
}
function printStats(statsAccumulator, api, startedAt, format) {
    logger.info(`Document: ${colors.magenta(api)} stats:\n\n`);
    switch (format) {
        case 'stylish':
            printStatsStylish(statsAccumulator);
            break;
        case 'json':
            printStatsJson(statsAccumulator);
            break;
        case 'markdown':
            printStatsMarkdown(statsAccumulator);
            break;
    }
    printExecutionTime('stats', startedAt, api);
}
export async function handleStats({ argv, config, collectSpecData }) {
    const [{ path }] = await getFallbackApisOrExit(argv.api ? [argv.api] : [], config);
    const externalRefResolver = new BaseResolver(config.resolve);
    const { bundle: document } = await bundle({ config, ref: path });
    collectSpecData?.(document.parsed);
    const specVersion = detectSpec(document.parsed);
    const types = normalizeTypes(config.extendTypes(getTypes(specVersion), specVersion), config);
    const startedAt = performance.now();
    const ctx = {
        problems: [],
        specVersion,
        config,
        visitorsData: {},
    };
    const resolvedRefMap = await resolveDocument({
        rootDocument: document,
        rootType: types.Root,
        externalRefResolver,
    });
    const statsVisitor = normalizeVisitors([
        {
            severity: 'warn',
            ruleId: 'stats',
            visitor: Stats(statsAccumulator),
        },
    ], types);
    walkDocument({
        document,
        rootType: types.Root,
        normalizedVisitors: statsVisitor,
        resolvedRefMap,
        ctx,
    });
    printStats(statsAccumulator, path, startedAt, argv.format);
}
//# sourceMappingURL=stats.js.map