"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = evalFunctionExpr;
const assertions_ts_1 = require("../../utils/assertions.js");
const results_ts_1 = require("../results.js");
const function_argument_ts_1 = __importDefault(require("./function-argument.js"));
function coerceValueType(value) {
    if ((0, results_ts_1.isNodeList)(value)) {
        return value.length === 1 ? value[0] : results_ts_1.Nothing;
    }
    return value;
}
function evalFunctionExpr(ctx, item, node) {
    if (!isKnownFunction(ctx.functions, node.name)) {
        return false;
    }
    const fn = ctx.functions[node.name];
    if (fn.definition.parameters.length !== node.arguments.length) {
        return false;
    }
    const args = [];
    for (let i = 0; i < node.arguments.length; i++) {
        const value = (0, function_argument_ts_1.default)(ctx, item, node.arguments[i]);
        const param = fn.definition.parameters[i];
        switch (param) {
            case "ValueType":
                if (!(0, results_ts_1.isNodeList)(value) && !(0, results_ts_1.isJsonValue)(value)) {
                    return false;
                }
                args.push(coerceValueType(value));
                break;
            case "NodesType":
                if (!(0, results_ts_1.isNodeList)(value)) {
                    return false;
                }
                args.push(value);
                break;
            case "LogicalType":
                if (typeof value === "boolean") {
                    args.push(value);
                }
                else if ((0, results_ts_1.isNodeList)(value)) {
                    args.push(value.length > 0);
                }
                else {
                    return false;
                }
                break;
            default:
                (0, assertions_ts_1.assertNever)(param, "Unknown function argument type");
        }
    }
    // we could validate the return type here,
    // but currently all functions are well-typed when it comes to returned values
    return fn.declaration(ctx, 
    // @ts-expect-error
    ...args);
}
function isKnownFunction(functions, name) {
    return Object.hasOwn(functions, name);
}
//# sourceMappingURL=function-expr.js.map